/* automatically generated by rust-bindgen 0.69.5 */

#[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
#[repr(C)]
pub struct __BindgenComplex<T> {
    pub re: T,
    pub im: T,
}
pub type qreal = f64;
pub type qindex = ::std::os::raw::c_longlong;
pub type qcomp = __BindgenComplex<f64>;
extern "C" {
    #[doc = " @notdoced\n @nottested"]
    pub fn reportStr(str_: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @notdoced\n @nottested"]
    pub fn reportScalar(label: *const ::std::os::raw::c_char, num: qcomp);
}
#[doc = " @notdoced"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Qureg {
    pub isMultithreaded: ::std::os::raw::c_int,
    pub isGpuAccelerated: ::std::os::raw::c_int,
    pub isDistributed: ::std::os::raw::c_int,
    pub rank: ::std::os::raw::c_int,
    pub numNodes: ::std::os::raw::c_int,
    pub logNumNodes: ::std::os::raw::c_int,
    pub isDensityMatrix: ::std::os::raw::c_int,
    pub numQubits: ::std::os::raw::c_int,
    pub numAmps: qindex,
    pub logNumAmps: qindex,
    pub numAmpsPerNode: qindex,
    pub logNumAmpsPerNode: qindex,
    pub logNumColsPerNode: qindex,
    pub cpuAmps: *mut qcomp,
    pub gpuAmps: *mut qcomp,
    pub cpuCommBuffer: *mut qcomp,
    pub gpuCommBuffer: *mut qcomp,
}
#[test]
fn bindgen_test_layout_Qureg() {
    const UNINIT: ::std::mem::MaybeUninit<Qureg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Qureg>(),
        104usize,
        concat!("Size of: ", stringify!(Qureg))
    );
    assert_eq!(
        ::std::mem::align_of::<Qureg>(),
        8usize,
        concat!("Alignment of ", stringify!(Qureg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isMultithreaded) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Qureg),
            "::",
            stringify!(isMultithreaded)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isGpuAccelerated) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Qureg),
            "::",
            stringify!(isGpuAccelerated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isDistributed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Qureg),
            "::",
            stringify!(isDistributed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rank) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Qureg),
            "::",
            stringify!(rank)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numNodes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Qureg),
            "::",
            stringify!(numNodes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logNumNodes) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Qureg),
            "::",
            stringify!(logNumNodes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isDensityMatrix) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Qureg),
            "::",
            stringify!(isDensityMatrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numQubits) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Qureg),
            "::",
            stringify!(numQubits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numAmps) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Qureg),
            "::",
            stringify!(numAmps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logNumAmps) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Qureg),
            "::",
            stringify!(logNumAmps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numAmpsPerNode) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Qureg),
            "::",
            stringify!(numAmpsPerNode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logNumAmpsPerNode) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Qureg),
            "::",
            stringify!(logNumAmpsPerNode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logNumColsPerNode) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Qureg),
            "::",
            stringify!(logNumColsPerNode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpuAmps) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Qureg),
            "::",
            stringify!(cpuAmps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuAmps) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Qureg),
            "::",
            stringify!(gpuAmps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpuCommBuffer) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Qureg),
            "::",
            stringify!(cpuCommBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuCommBuffer) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Qureg),
            "::",
            stringify!(gpuCommBuffer)
        )
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn createQureg(numQubits: ::std::os::raw::c_int) -> Qureg;
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn createDensityQureg(numQubits: ::std::os::raw::c_int) -> Qureg;
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn createForcedQureg(numQubits: ::std::os::raw::c_int) -> Qureg;
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn createForcedDensityQureg(numQubits: ::std::os::raw::c_int) -> Qureg;
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn createCustomQureg(
        numQubits: ::std::os::raw::c_int,
        isDensMatr: ::std::os::raw::c_int,
        useDistrib: ::std::os::raw::c_int,
        useGpuAccel: ::std::os::raw::c_int,
        useMultithread: ::std::os::raw::c_int,
    ) -> Qureg;
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn createCloneQureg(qureg: Qureg) -> Qureg;
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn destroyQureg(qureg: Qureg);
}
extern "C" {
    #[doc = " @notdoced\n @nottested"]
    pub fn reportQuregParams(qureg: Qureg);
}
extern "C" {
    #[doc = " @notdoced\n @nottested"]
    pub fn reportQureg(qureg: Qureg);
}
extern "C" {
    #[doc = " @notdoced\n @nottested"]
    pub fn syncQuregFromGpu(qureg: Qureg);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn getQuregAmps(outAmps: *mut qcomp, qureg: Qureg, startInd: qindex, numAmps: qindex);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn getDensityQuregAmps(
        outAmps: *mut *mut qcomp,
        qureg: Qureg,
        startRow: qindex,
        startCol: qindex,
        numRows: qindex,
        numCols: qindex,
    );
}
extern "C" {
    #[doc = " @ingroup qureg_get\n @notdoced"]
    pub fn getQuregAmp(qureg: Qureg, index: qindex) -> qcomp;
}
extern "C" {
    #[doc = " @ingroup qureg_get\n @notdoced"]
    pub fn getDensityQuregAmp(qureg: Qureg, row: qindex, column: qindex) -> qcomp;
}
#[doc = " @notdoced"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PauliStr {
    pub lowPaulis: ::std::os::raw::c_ulonglong,
    pub highPaulis: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_PauliStr() {
    const UNINIT: ::std::mem::MaybeUninit<PauliStr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PauliStr>(),
        16usize,
        concat!("Size of: ", stringify!(PauliStr))
    );
    assert_eq!(
        ::std::mem::align_of::<PauliStr>(),
        8usize,
        concat!("Alignment of ", stringify!(PauliStr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lowPaulis) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PauliStr),
            "::",
            stringify!(lowPaulis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).highPaulis) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PauliStr),
            "::",
            stringify!(highPaulis)
        )
    );
}
#[doc = " @notdoced"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PauliStrSum {
    pub numTerms: qindex,
    pub strings: *mut PauliStr,
    pub coeffs: *mut qcomp,
    pub isApproxHermitian: *mut ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PauliStrSum() {
    const UNINIT: ::std::mem::MaybeUninit<PauliStrSum> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PauliStrSum>(),
        32usize,
        concat!("Size of: ", stringify!(PauliStrSum))
    );
    assert_eq!(
        ::std::mem::align_of::<PauliStrSum>(),
        8usize,
        concat!("Alignment of ", stringify!(PauliStrSum))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numTerms) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PauliStrSum),
            "::",
            stringify!(numTerms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strings) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PauliStrSum),
            "::",
            stringify!(strings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coeffs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PauliStrSum),
            "::",
            stringify!(coeffs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isApproxHermitian) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PauliStrSum),
            "::",
            stringify!(isApproxHermitian)
        )
    );
}
extern "C" {
    #[doc = " @ingroup paulis_create\n @notdoced"]
    pub fn getPauliStr(
        paulis: *const ::std::os::raw::c_char,
        indices: *mut ::std::os::raw::c_int,
        numPaulis: ::std::os::raw::c_int,
    ) -> PauliStr;
}
extern "C" {
    #[doc = " @ingroup paulis_create\n @notdoced"]
    pub fn createPauliStrSum(
        strings: *mut PauliStr,
        coeffs: *mut qcomp,
        numTerms: qindex,
    ) -> PauliStrSum;
}
extern "C" {
    #[doc = " @ingroup paulis_create\n @notdoced"]
    pub fn createInlinePauliStrSum(str_: *const ::std::os::raw::c_char) -> PauliStrSum;
}
extern "C" {
    #[doc = " @ingroup paulis_create\n @notdoced"]
    pub fn createPauliStrSumFromFile(fn_: *const ::std::os::raw::c_char) -> PauliStrSum;
}
extern "C" {
    #[doc = " @ingroup paulis_create\n @notdoced"]
    pub fn createPauliStrSumFromReversedFile(fn_: *const ::std::os::raw::c_char) -> PauliStrSum;
}
extern "C" {
    #[doc = " @ingroup paulis_destroy\n @notdoced"]
    pub fn destroyPauliStrSum(sum: PauliStrSum);
}
extern "C" {
    #[doc = " @ingroup paulis_reporters\n @notdoced\n @nottested"]
    pub fn reportPauliStr(str_: PauliStr);
}
extern "C" {
    #[doc = " @ingroup paulis_reporters\n @notdoced\n @nottested"]
    pub fn reportPauliStrSum(str_: PauliStrSum);
}
#[doc = " @notdoced"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CompMatr1 {
    pub numQubits: ::std::os::raw::c_int,
    pub numRows: qindex,
    pub elems: [[qcomp; 2usize]; 2usize],
}
#[test]
fn bindgen_test_layout_CompMatr1() {
    const UNINIT: ::std::mem::MaybeUninit<CompMatr1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CompMatr1>(),
        80usize,
        concat!("Size of: ", stringify!(CompMatr1))
    );
    assert_eq!(
        ::std::mem::align_of::<CompMatr1>(),
        8usize,
        concat!("Alignment of ", stringify!(CompMatr1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numQubits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CompMatr1),
            "::",
            stringify!(numQubits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numRows) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CompMatr1),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elems) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CompMatr1),
            "::",
            stringify!(elems)
        )
    );
}
#[doc = " @notdoced"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CompMatr2 {
    pub numQubits: ::std::os::raw::c_int,
    pub numRows: qindex,
    pub elems: [[qcomp; 4usize]; 4usize],
}
#[test]
fn bindgen_test_layout_CompMatr2() {
    const UNINIT: ::std::mem::MaybeUninit<CompMatr2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CompMatr2>(),
        272usize,
        concat!("Size of: ", stringify!(CompMatr2))
    );
    assert_eq!(
        ::std::mem::align_of::<CompMatr2>(),
        8usize,
        concat!("Alignment of ", stringify!(CompMatr2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numQubits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CompMatr2),
            "::",
            stringify!(numQubits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numRows) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CompMatr2),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elems) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CompMatr2),
            "::",
            stringify!(elems)
        )
    );
}
#[doc = " @notdoced"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CompMatr {
    pub numQubits: ::std::os::raw::c_int,
    pub numRows: qindex,
    pub isApproxUnitary: *mut ::std::os::raw::c_int,
    pub isApproxHermitian: *mut ::std::os::raw::c_int,
    pub wasGpuSynced: *mut ::std::os::raw::c_int,
    pub cpuElems: *mut *mut qcomp,
    pub cpuElemsFlat: *mut qcomp,
    pub gpuElemsFlat: *mut qcomp,
}
#[test]
fn bindgen_test_layout_CompMatr() {
    const UNINIT: ::std::mem::MaybeUninit<CompMatr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CompMatr>(),
        64usize,
        concat!("Size of: ", stringify!(CompMatr))
    );
    assert_eq!(
        ::std::mem::align_of::<CompMatr>(),
        8usize,
        concat!("Alignment of ", stringify!(CompMatr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numQubits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CompMatr),
            "::",
            stringify!(numQubits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numRows) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CompMatr),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isApproxUnitary) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CompMatr),
            "::",
            stringify!(isApproxUnitary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isApproxHermitian) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CompMatr),
            "::",
            stringify!(isApproxHermitian)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wasGpuSynced) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CompMatr),
            "::",
            stringify!(wasGpuSynced)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpuElems) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CompMatr),
            "::",
            stringify!(cpuElems)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpuElemsFlat) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CompMatr),
            "::",
            stringify!(cpuElemsFlat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuElemsFlat) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CompMatr),
            "::",
            stringify!(gpuElemsFlat)
        )
    );
}
#[doc = " @notdoced"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DiagMatr1 {
    pub numQubits: ::std::os::raw::c_int,
    pub numElems: qindex,
    pub elems: [qcomp; 2usize],
}
#[test]
fn bindgen_test_layout_DiagMatr1() {
    const UNINIT: ::std::mem::MaybeUninit<DiagMatr1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DiagMatr1>(),
        48usize,
        concat!("Size of: ", stringify!(DiagMatr1))
    );
    assert_eq!(
        ::std::mem::align_of::<DiagMatr1>(),
        8usize,
        concat!("Alignment of ", stringify!(DiagMatr1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numQubits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DiagMatr1),
            "::",
            stringify!(numQubits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numElems) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DiagMatr1),
            "::",
            stringify!(numElems)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elems) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DiagMatr1),
            "::",
            stringify!(elems)
        )
    );
}
#[doc = " @notdoced"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DiagMatr2 {
    pub numQubits: ::std::os::raw::c_int,
    pub numElems: qindex,
    pub elems: [qcomp; 4usize],
}
#[test]
fn bindgen_test_layout_DiagMatr2() {
    const UNINIT: ::std::mem::MaybeUninit<DiagMatr2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DiagMatr2>(),
        80usize,
        concat!("Size of: ", stringify!(DiagMatr2))
    );
    assert_eq!(
        ::std::mem::align_of::<DiagMatr2>(),
        8usize,
        concat!("Alignment of ", stringify!(DiagMatr2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numQubits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DiagMatr2),
            "::",
            stringify!(numQubits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numElems) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DiagMatr2),
            "::",
            stringify!(numElems)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elems) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DiagMatr2),
            "::",
            stringify!(elems)
        )
    );
}
#[doc = " @notdoced"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DiagMatr {
    pub numQubits: ::std::os::raw::c_int,
    pub numElems: qindex,
    pub isApproxUnitary: *mut ::std::os::raw::c_int,
    pub isApproxHermitian: *mut ::std::os::raw::c_int,
    #[doc = " @todo currently unused (relevant to not-yet-implemented calc-expec-val)"]
    pub isApproxNonZero: *mut ::std::os::raw::c_int,
    #[doc = " @todo currently unused (relevant to not-yet-implemented calc-expec-val)"]
    pub isStrictlyNonNegative: *mut ::std::os::raw::c_int,
    pub wasGpuSynced: *mut ::std::os::raw::c_int,
    pub cpuElems: *mut qcomp,
    pub gpuElems: *mut qcomp,
}
#[test]
fn bindgen_test_layout_DiagMatr() {
    const UNINIT: ::std::mem::MaybeUninit<DiagMatr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DiagMatr>(),
        72usize,
        concat!("Size of: ", stringify!(DiagMatr))
    );
    assert_eq!(
        ::std::mem::align_of::<DiagMatr>(),
        8usize,
        concat!("Alignment of ", stringify!(DiagMatr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numQubits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DiagMatr),
            "::",
            stringify!(numQubits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numElems) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DiagMatr),
            "::",
            stringify!(numElems)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isApproxUnitary) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DiagMatr),
            "::",
            stringify!(isApproxUnitary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isApproxHermitian) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DiagMatr),
            "::",
            stringify!(isApproxHermitian)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isApproxNonZero) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DiagMatr),
            "::",
            stringify!(isApproxNonZero)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isStrictlyNonNegative) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DiagMatr),
            "::",
            stringify!(isStrictlyNonNegative)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wasGpuSynced) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DiagMatr),
            "::",
            stringify!(wasGpuSynced)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpuElems) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(DiagMatr),
            "::",
            stringify!(cpuElems)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuElems) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(DiagMatr),
            "::",
            stringify!(gpuElems)
        )
    );
}
#[doc = " @notdoced"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FullStateDiagMatr {
    pub numQubits: ::std::os::raw::c_int,
    pub numElems: qindex,
    pub isGpuAccelerated: ::std::os::raw::c_int,
    pub isMultithreaded: ::std::os::raw::c_int,
    pub isDistributed: ::std::os::raw::c_int,
    pub numElemsPerNode: qindex,
    pub isApproxUnitary: *mut ::std::os::raw::c_int,
    pub isApproxHermitian: *mut ::std::os::raw::c_int,
    pub isApproxNonZero: *mut ::std::os::raw::c_int,
    pub isStrictlyNonNegative: *mut ::std::os::raw::c_int,
    pub wasGpuSynced: *mut ::std::os::raw::c_int,
    pub cpuElems: *mut qcomp,
    pub gpuElems: *mut qcomp,
}
#[test]
fn bindgen_test_layout_FullStateDiagMatr() {
    const UNINIT: ::std::mem::MaybeUninit<FullStateDiagMatr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FullStateDiagMatr>(),
        96usize,
        concat!("Size of: ", stringify!(FullStateDiagMatr))
    );
    assert_eq!(
        ::std::mem::align_of::<FullStateDiagMatr>(),
        8usize,
        concat!("Alignment of ", stringify!(FullStateDiagMatr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numQubits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FullStateDiagMatr),
            "::",
            stringify!(numQubits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numElems) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FullStateDiagMatr),
            "::",
            stringify!(numElems)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isGpuAccelerated) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FullStateDiagMatr),
            "::",
            stringify!(isGpuAccelerated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isMultithreaded) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FullStateDiagMatr),
            "::",
            stringify!(isMultithreaded)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isDistributed) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FullStateDiagMatr),
            "::",
            stringify!(isDistributed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numElemsPerNode) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FullStateDiagMatr),
            "::",
            stringify!(numElemsPerNode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isApproxUnitary) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FullStateDiagMatr),
            "::",
            stringify!(isApproxUnitary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isApproxHermitian) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FullStateDiagMatr),
            "::",
            stringify!(isApproxHermitian)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isApproxNonZero) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(FullStateDiagMatr),
            "::",
            stringify!(isApproxNonZero)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isStrictlyNonNegative) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(FullStateDiagMatr),
            "::",
            stringify!(isStrictlyNonNegative)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wasGpuSynced) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(FullStateDiagMatr),
            "::",
            stringify!(wasGpuSynced)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpuElems) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(FullStateDiagMatr),
            "::",
            stringify!(cpuElems)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuElems) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(FullStateDiagMatr),
            "::",
            stringify!(gpuElems)
        )
    );
}
extern "C" {
    #[doc = " @ingroup matrices_create\n @notdoced"]
    pub fn createCompMatr(numQubits: ::std::os::raw::c_int) -> CompMatr;
}
extern "C" {
    #[doc = " @ingroup matrices_create\n @notdoced"]
    pub fn createDiagMatr(numQubits: ::std::os::raw::c_int) -> DiagMatr;
}
extern "C" {
    #[doc = " @ingroup matrices_create\n @notdoced"]
    pub fn createFullStateDiagMatr(numQubits: ::std::os::raw::c_int) -> FullStateDiagMatr;
}
extern "C" {
    #[doc = " @ingroup matrices_create\n @notdoced"]
    pub fn createCustomFullStateDiagMatr(
        numQubits: ::std::os::raw::c_int,
        useDistrib: ::std::os::raw::c_int,
        useGpuAccel: ::std::os::raw::c_int,
        useMultithread: ::std::os::raw::c_int,
    ) -> FullStateDiagMatr;
}
extern "C" {
    #[doc = " @ingroup matrices_destroy\n @notdoced"]
    pub fn destroyCompMatr(matrix: CompMatr);
}
extern "C" {
    #[doc = " @ingroup matrices_destroy\n @notdoced"]
    pub fn destroyDiagMatr(matrix: DiagMatr);
}
extern "C" {
    #[doc = " @ingroup matrices_destroy\n @notdoced"]
    pub fn destroyFullStateDiagMatr(matrix: FullStateDiagMatr);
}
extern "C" {
    #[doc = " @ingroup matrices_setters\n @notdoced"]
    pub fn setCompMatr(matr: CompMatr, vals: *mut *mut qcomp);
}
extern "C" {
    #[doc = " @ingroup matrices_setters\n @notdoced"]
    pub fn setDiagMatr(out: DiagMatr, in_: *mut qcomp);
}
extern "C" {
    #[doc = " @ingroup matrices_setters\n @notdoced\n @nottested"]
    pub fn setFullStateDiagMatr(
        out: FullStateDiagMatr,
        startInd: qindex,
        in_: *mut qcomp,
        numElems: qindex,
    );
}
extern "C" {
    #[doc = " @ingroup matrices_setters\n @notdoced\n @nottested"]
    pub fn setDiagMatrFromMultiVarFunc(
        out: DiagMatr,
        func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut qindex) -> qcomp>,
        numQubitsPerVar: *mut ::std::os::raw::c_int,
        numVars: ::std::os::raw::c_int,
        areSigned: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @ingroup matrices_setters\n @notdoced\n @nottested"]
    pub fn setDiagMatrFromMultiDimLists(
        out: DiagMatr,
        lists: *mut ::std::os::raw::c_void,
        numQubitsPerDim: *mut ::std::os::raw::c_int,
        numDims: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @ingroup matrices_create\n @notdoced\n @nottested"]
    pub fn createFullStateDiagMatrFromPauliStrSum(in_: PauliStrSum) -> FullStateDiagMatr;
}
extern "C" {
    #[doc = " @ingroup matrices_setters\n @notdoced\n @nottested"]
    pub fn setFullStateDiagMatrFromPauliStrSum(out: FullStateDiagMatr, in_: PauliStrSum);
}
extern "C" {
    #[doc = " @ingroup matrices_setters\n @notdoced\n @nottested"]
    pub fn setFullStateDiagMatrFromMultiVarFunc(
        out: FullStateDiagMatr,
        func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut qindex) -> qcomp>,
        numQubitsPerVar: *mut ::std::os::raw::c_int,
        numVars: ::std::os::raw::c_int,
        areSigned: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @ingroup matrices_setters\n @notdoced\n @nottested"]
    pub fn setFullStateDiagMatrFromMultiDimLists(
        out: FullStateDiagMatr,
        lists: *mut ::std::os::raw::c_void,
        numQubitsPerDim: *mut ::std::os::raw::c_int,
        numDims: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @ingroup matrices_reporters\n @notdoced\n @nottested"]
    pub fn reportCompMatr1(matrix: CompMatr1);
}
extern "C" {
    #[doc = " @ingroup matrices_reporters\n @notdoced\n @nottested"]
    pub fn reportCompMatr2(matrix: CompMatr2);
}
extern "C" {
    #[doc = " @ingroup matrices_reporters\n @notdoced\n @nottested"]
    pub fn reportCompMatr(matrix: CompMatr);
}
extern "C" {
    #[doc = " @ingroup matrices_reporters\n @notdoced\n @nottested"]
    pub fn reportDiagMatr1(matrix: DiagMatr1);
}
extern "C" {
    #[doc = " @ingroup matrices_reporters\n @notdoced\n @nottested"]
    pub fn reportDiagMatr2(matrix: DiagMatr2);
}
extern "C" {
    #[doc = " @ingroup matrices_reporters\n @notdoced\n @nottested"]
    pub fn reportDiagMatr(matrix: DiagMatr);
}
extern "C" {
    #[doc = " @ingroup matrices_reporters\n @notdoced\n @nottested"]
    pub fn reportFullStateDiagMatr(matr: FullStateDiagMatr);
}
extern "C" {
    #[doc = " Calculates the expectation value of the given Pauli string observable @p str under the given\n state @p qureg without modifying it.\n\n @formulae\n Let @f$ \\pstr = @f$ @p str.\n - When @p qureg is a statevector @f$\\svpsi@f$, this function returns\n   @f[\n\\brapsi \\pstr \\svpsi \\in \\mathbb{R}.\n   @f]\n - When @p qureg is a density matrix @f$\\dmrho@f$, this function returns the real component of\n   @f[\n\\tr{ \\pstr \\dmrho }\n   @f]\n   which is exact when @f$\\dmrho@f$ is physical (specifically Hermitian).\n\n @constraints\n - The returned value is always real, even when @p qureg is an unnormalised density matrix, in\n   which case the imaginary component of the above expression is neglected.\n   The full complex value can be obtained using calcExpecNonHermitianPauliStrSum().\n\n @equivalence\n - When @p str is general, this function is equivalent to calling calcExpecPauliStrSum() with a\n   PauliStrSum composed of only a single PauliStr term and a unity coefficient.\n - When @p str @f$ = \\id^\\otimes @f$, the output is equivalent to that of calcTotalProb().\n\n @myexample\n ```\nQureg qureg = createQureg(4);\nPauliStr str = getPauliStr(\"XYZ\");\n\nqreal expec = calcExpecPauliStr(qureg, str);\nreportScalar(\"expec\", expec);\n ```\n\n @see\n - calcExpecPauliStrSum()\n - calcExpecFullStateDiagMatr()\n @param[in] qureg the reference state.\n @param[in] str   the observable operator.\n @returns The real component of the expectation value.\n @throws invalidQuESTInputError()\n - if @p qureg is uninitialised.\n - if @p str contains a (non-identity) Pauli upon a higher-index qubit than exists in @p qureg.\n - if the output (with unreturned imaginary component) is not approximately real.\n @notvalidated\n @author Tyson Jones"]
    pub fn calcExpecPauliStr(qureg: Qureg, str_: PauliStr) -> qreal;
}
extern "C" {
    #[doc = " Calculates the expectation value of the given Hermitian observable @p sum - a weighted sum of\n Pauli strings - under the given state @p qureg, without modifying it.\n\n @formulae\n Let @f$ \\hat{H} = @f$ @p sum.\n - When @p qureg is a statevector @f$\\svpsi@f$, this function returns\n   @f[\n\\brapsi \\hat{H} \\svpsi \\in \\mathbb{R}.\n   @f]\n - When @p qureg is a density matrix @f$\\dmrho@f$, this function returns the real component of\n   @f[\n\\tr{ \\hat{H} \\dmrho }\n   @f]\n   which is the exact expectation value when @f$\\dmrho@f$ is physical (specifically Hermitian).\n\n @constraints\n - Hermiticity of @p sum requires that every coefficient within is real.\n   Validation will check @p sum is _approximately_ Hermitian, i.e. that\n   @f[\n|\\im{c}| \\le \\valeps\n   @f]\n   for all @f$c \\in @f$ `sum.coeffs`. Adjust @f$\\valeps@f$ using setValidationEpsilon().\n - The returned value is always real, and the imaginary component is neglected even when\n   Hermiticity validation is relaxed and/or @p qureg is an unnormalised density matrix.\n   The full complex value can be obtained using calcExpecNonHermitianPauliStrSum().\n\n @equivalence\n - This function is mathematically equivalent to (albeit faster than) calling calcExpecPauliStr() upon\n   each constituent @p PauliStr within @p sum, weighting each by its corresponding coefficient, and\n   summing the outputs.\n - When @p sum contains only @f$\\pauliz@f$ and @f$\\id@f$ operators, its corresponding operator matrix\n   is diagonal, and could be instead effected with calcExpecFullStateDiagMatr(). This may be faster when\n   @p sum contains very-many terms and operates upon all qubits of the register.\n\n @myexample\n ```\nQureg qureg = createQureg(5);\nPauliStrSum sum = createInlinePauliStrSum(R\"(\n0.123 XXIXX\n1.234 XYZXZ\n-1E-2 IIIII\n)\");\n\nqreal expec = calcExpecPauliStrSum(qureg, sum);\nreportScalar(\"expec\", expec);\n ```\n @param[in] qureg the reference state.\n @param[in] sum   the observable operator.\n @returns The real component of the expectation value.\n @throws invalidQuESTInputError()\n - if @p qureg or @p sum are uninitialised.\n - if any PauliStr in @p sum targets a higher-index qubit than exists in @p qureg.\n - if @p sum is not approximately Hermitian.\n - if the output (with unreturned imaginary component) is not approximately real.\n @notvalidated\n @see\n - calcExpecNonHermitianPauliStrSum()\n - calcExpecFullStateDiagMatr()\n @author Tyson Jones"]
    pub fn calcExpecPauliStrSum(qureg: Qureg, sum: PauliStrSum) -> qreal;
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn calcExpecFullStateDiagMatr(qureg: Qureg, matr: FullStateDiagMatr) -> qreal;
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn calcExpecFullStateDiagMatrPower(
        qureg: Qureg,
        matr: FullStateDiagMatr,
        exponent: qreal,
    ) -> qreal;
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn calcProbOfBasisState(qureg: Qureg, index: qindex) -> qreal;
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn calcProbOfQubitOutcome(
        qureg: Qureg,
        qubit: ::std::os::raw::c_int,
        outcome: ::std::os::raw::c_int,
    ) -> qreal;
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn calcProbOfMultiQubitOutcome(
        qureg: Qureg,
        qubits: *mut ::std::os::raw::c_int,
        outcomes: *mut ::std::os::raw::c_int,
        numQubits: ::std::os::raw::c_int,
    ) -> qreal;
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn calcProbsOfAllMultiQubitOutcomes(
        outcomeProbs: *mut qreal,
        qureg: Qureg,
        qubits: *mut ::std::os::raw::c_int,
        numQubits: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn calcTotalProb(qureg: Qureg) -> qreal;
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn calcPurity(qureg: Qureg) -> qreal;
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn calcFidelity(qureg: Qureg, other: Qureg) -> qreal;
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn calcDistance(qureg1: Qureg, qureg2: Qureg) -> qreal;
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn calcPartialTrace(
        qureg: Qureg,
        traceOutQubits: *mut ::std::os::raw::c_int,
        numTraceQubits: ::std::os::raw::c_int,
    ) -> Qureg;
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn calcReducedDensityMatrix(
        qureg: Qureg,
        retainQubits: *mut ::std::os::raw::c_int,
        numRetainQubits: ::std::os::raw::c_int,
    ) -> Qureg;
}
extern "C" {
    #[doc = " @ingroup calc_comparisons\n @notdoced\n @notvalidated"]
    pub fn calcInnerProduct(qureg1: Qureg, qureg2: Qureg) -> qcomp;
}
extern "C" {
    #[doc = " @ingroup calc_expec\n @notdoced\n @notvalidated"]
    pub fn calcExpecNonHermitianPauliStrSum(qureg: Qureg, sum: PauliStrSum) -> qcomp;
}
extern "C" {
    #[doc = " @ingroup calc_expec\n @notdoced\n @notvalidated"]
    pub fn calcExpecNonHermitianFullStateDiagMatr(qureg: Qureg, matr: FullStateDiagMatr) -> qcomp;
}
extern "C" {
    #[doc = " @ingroup calc_expec\n @notdoced\n @notvalidated"]
    pub fn calcExpecNonHermitianFullStateDiagMatrPower(
        qureg: Qureg,
        matrix: FullStateDiagMatr,
        exponent: qcomp,
    ) -> qcomp;
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn setSeeds(seeds: *mut ::std::os::raw::c_uint, numSeeds: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn setSeedsToDefault();
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn getSeeds(seeds: *mut ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn getNumSeeds() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn setInputErrorHandler(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                func: *const ::std::os::raw::c_char,
                msg: *const ::std::os::raw::c_char,
            ),
        >,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn setValidationOn();
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn setValidationOff();
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn setValidationEpsilonToDefault();
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn setValidationEpsilon(eps: qreal);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn getValidationEpsilon() -> qreal;
}
extern "C" {
    #[doc = " @notdoced\n @nottested"]
    pub fn setMaxNumReportedItems(numRows: qindex, numCols: qindex);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn setMaxNumReportedSigFigs(numSigFigs: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn setNumReportedNewlines(numNewlines: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn getGpuCacheSize() -> qindex;
}
extern "C" {
    #[doc = " @notdoced\n @nottested"]
    pub fn getEnvironmentString(str_: *mut ::std::os::raw::c_char);
}
#[doc = " @notdoced"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SuperOp {
    pub numQubits: ::std::os::raw::c_int,
    pub numRows: qindex,
    pub cpuElems: *mut *mut qcomp,
    pub cpuElemsFlat: *mut qcomp,
    pub gpuElemsFlat: *mut qcomp,
    pub wasGpuSynced: *mut ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SuperOp() {
    const UNINIT: ::std::mem::MaybeUninit<SuperOp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SuperOp>(),
        48usize,
        concat!("Size of: ", stringify!(SuperOp))
    );
    assert_eq!(
        ::std::mem::align_of::<SuperOp>(),
        8usize,
        concat!("Alignment of ", stringify!(SuperOp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numQubits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SuperOp),
            "::",
            stringify!(numQubits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numRows) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SuperOp),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpuElems) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SuperOp),
            "::",
            stringify!(cpuElems)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpuElemsFlat) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SuperOp),
            "::",
            stringify!(cpuElemsFlat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuElemsFlat) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SuperOp),
            "::",
            stringify!(gpuElemsFlat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wasGpuSynced) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SuperOp),
            "::",
            stringify!(wasGpuSynced)
        )
    );
}
#[doc = " @notdoced"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KrausMap {
    pub numQubits: ::std::os::raw::c_int,
    pub numMatrices: ::std::os::raw::c_int,
    pub numRows: qindex,
    pub matrices: *mut *mut *mut qcomp,
    pub superop: SuperOp,
    pub isApproxCPTP: *mut ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_KrausMap() {
    const UNINIT: ::std::mem::MaybeUninit<KrausMap> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<KrausMap>(),
        80usize,
        concat!("Size of: ", stringify!(KrausMap))
    );
    assert_eq!(
        ::std::mem::align_of::<KrausMap>(),
        8usize,
        concat!("Alignment of ", stringify!(KrausMap))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numQubits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KrausMap),
            "::",
            stringify!(numQubits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numMatrices) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(KrausMap),
            "::",
            stringify!(numMatrices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numRows) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(KrausMap),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matrices) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(KrausMap),
            "::",
            stringify!(matrices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).superop) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(KrausMap),
            "::",
            stringify!(superop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isApproxCPTP) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(KrausMap),
            "::",
            stringify!(isApproxCPTP)
        )
    );
}
extern "C" {
    #[doc = " @ingroup channels_create\n @notdoced"]
    pub fn createKrausMap(
        numQubits: ::std::os::raw::c_int,
        numOperators: ::std::os::raw::c_int,
    ) -> KrausMap;
}
extern "C" {
    #[doc = " @ingroup channels_destroy\n @notdoced"]
    pub fn destroyKrausMap(map: KrausMap);
}
extern "C" {
    #[doc = " @ingroup channels_reporters\n @notdoced\n @nottested"]
    pub fn reportKrausMap(map: KrausMap);
}
extern "C" {
    #[doc = " @ingroup channels_create\n @notdoced"]
    pub fn createSuperOp(numQubits: ::std::os::raw::c_int) -> SuperOp;
}
extern "C" {
    #[doc = " @ingroup channels_destroy\n @notdoced"]
    pub fn destroySuperOp(op: SuperOp);
}
extern "C" {
    #[doc = " @ingroup channels_reporters\n @notdoced\n @nottested"]
    pub fn reportSuperOp(op: SuperOp);
}
extern "C" {
    #[doc = " @ingroup channels_setters\n @notdoced"]
    pub fn setKrausMap(map: KrausMap, matrices: *mut *mut *mut qcomp);
}
extern "C" {
    #[doc = " @ingroup channels_setters\n @notdoced"]
    pub fn setSuperOp(op: SuperOp, matrix: *mut *mut qcomp);
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn mixDephasing(qureg: Qureg, qubit: ::std::os::raw::c_int, prob: qreal);
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn mixTwoQubitDephasing(
        qureg: Qureg,
        qubit1: ::std::os::raw::c_int,
        qubit2: ::std::os::raw::c_int,
        prob: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn mixDepolarising(qureg: Qureg, qubit: ::std::os::raw::c_int, prob: qreal);
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn mixTwoQubitDepolarising(
        qureg: Qureg,
        qubit1: ::std::os::raw::c_int,
        qubit2: ::std::os::raw::c_int,
        prob: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn mixDamping(qureg: Qureg, qubit: ::std::os::raw::c_int, prob: qreal);
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn mixPaulis(
        qureg: Qureg,
        qubit: ::std::os::raw::c_int,
        probX: qreal,
        probY: qreal,
        probZ: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn mixQureg(qureg: Qureg, other: Qureg, prob: qreal);
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn mixKrausMap(
        qureg: Qureg,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
        map: KrausMap,
    );
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn mixSuperOp(
        qureg: Qureg,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
        superop: SuperOp,
    );
}
#[doc = " @notdoced"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QuESTEnv {
    pub isMultithreaded: ::std::os::raw::c_int,
    pub isGpuAccelerated: ::std::os::raw::c_int,
    pub isDistributed: ::std::os::raw::c_int,
    pub rank: ::std::os::raw::c_int,
    pub numNodes: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_QuESTEnv() {
    const UNINIT: ::std::mem::MaybeUninit<QuESTEnv> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<QuESTEnv>(),
        20usize,
        concat!("Size of: ", stringify!(QuESTEnv))
    );
    assert_eq!(
        ::std::mem::align_of::<QuESTEnv>(),
        4usize,
        concat!("Alignment of ", stringify!(QuESTEnv))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isMultithreaded) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QuESTEnv),
            "::",
            stringify!(isMultithreaded)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isGpuAccelerated) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(QuESTEnv),
            "::",
            stringify!(isGpuAccelerated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isDistributed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(QuESTEnv),
            "::",
            stringify!(isDistributed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rank) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(QuESTEnv),
            "::",
            stringify!(rank)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numNodes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(QuESTEnv),
            "::",
            stringify!(numNodes)
        )
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn initQuESTEnv();
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn initCustomQuESTEnv(
        useDistrib: ::std::os::raw::c_int,
        useGpuAccel: ::std::os::raw::c_int,
        useMultithread: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn finalizeQuESTEnv();
}
extern "C" {
    #[doc = " @notdoced\n @nottested"]
    pub fn reportQuESTEnv();
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn getQuESTEnv() -> QuESTEnv;
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn initBlankState(qureg: Qureg);
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn initZeroState(qureg: Qureg);
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn initPlusState(qureg: Qureg);
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated\n @nottested"]
    pub fn initPureState(qureg: Qureg, pure_: Qureg);
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn initClassicalState(qureg: Qureg, stateInd: qindex);
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn initDebugState(qureg: Qureg);
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn initArbitraryPureState(qureg: Qureg, amps: *mut qcomp);
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn initRandomPureState(qureg: Qureg);
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn initRandomMixedState(qureg: Qureg, numPureStates: qindex);
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn setQuregAmps(qureg: Qureg, startInd: qindex, amps: *mut qcomp, numAmps: qindex);
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn setDensityQuregAmps(
        qureg: Qureg,
        startRow: qindex,
        startCol: qindex,
        amps: *mut *mut qcomp,
        numRows: qindex,
        numCols: qindex,
    );
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn setDensityQuregFlatAmps(
        qureg: Qureg,
        startInd: qindex,
        amps: *mut qcomp,
        numAmps: qindex,
    );
}
extern "C" {
    #[doc = " @notdoced\n @nottested"]
    pub fn setQuregToClone(targetQureg: Qureg, copyQureg: Qureg);
}
extern "C" {
    #[doc = " @notdoced\n @nottested"]
    pub fn setQuregToSuperposition(
        facOut: qcomp,
        out: Qureg,
        fac1: qcomp,
        qureg1: Qureg,
        fac2: qcomp,
        qureg2: Qureg,
    );
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn setQuregToRenormalized(qureg: Qureg) -> qreal;
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn setQuregToPauliStrSum(qureg: Qureg, sum: PauliStrSum);
}
extern "C" {
    #[doc = " @notdoced\n @nottested"]
    pub fn setQuregToPartialTrace(
        out: Qureg,
        in_: Qureg,
        traceOutQubits: *mut ::std::os::raw::c_int,
        numTraceQubits: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced\n @nottested"]
    pub fn setQuregToReducedDensityMatrix(
        out: Qureg,
        in_: Qureg,
        retainQubits: *mut ::std::os::raw::c_int,
        numRetainQubits: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Applies a general one-qubit dense unitary @p matrix to the specified @p target\n qubit of @p qureg.\n\n @diagram\n @dot\ndigraph {\nrankdir=LR;\nnode [fontsize=10, fontname=\"Menlo\"];\nedge [dir=none];\n\nwireL [shape=plaintext, label=\"target\"];\nwireR [shape=plaintext, label=\"\"];\ngate  [shape=box,    label=\"matrix\"];\n\nwireL -> gate -> wireR\n}\n @enddot\n\n @formulae\n Let @f$ \\hat{U} = @f$ @p matrix, @f$ t = @f$ @p target, and let @f$\\hat{U}_t@f$\n notate operating @f$\\hat{U}@f$ upon the @f$ t @f$-th qubit among@f$ N @f$, i.e.\n @f[\n\\hat{U}_t \\equiv \\id^{N-t} \\otimes \\hat{U} \\otimes \\id^{t-1}.\n @f]\n Then,\n - When @p qureg is a statevector @f$ \\svpsi @f$, this function effects\n   @f[\n\\svpsi \\rightarrow \\hat{U}_t \\, \\svpsi.\n   @f]\n - When @p qureg is a density matrix @f$\\dmrho@f$, this function effects\n   @f[\n\\dmrho \\rightarrow \\hat{U}_t \\, \\dmrho \\, {\\hat{U}_t}^\\dagger.\n   @f]\n\n @constraints\n - Unitarity of @f$ \\hat{U} = @f$ @p matrix requires that\n   @f$ \\hat{U} \\hat{U}^\\dagger = \\id @f$. Validation will check that @p matrix is\n   approximately unitarity via\n   @f[\n\\max\\limits_{ij} \\Big|\\left(\\hat{U} \\hat{U}^\\dagger - \\id\\right)_{ij}\\Big|^2 \\le \\valeps\n   @f]\n   where the validation epsilon @f$ \\valeps @f$ can be adjusted with setValidationEpsilon().\n\n @myexample\n ```\nQureg qureg = createQureg(5);\n\nCompMatr1 matrix = getInlineCompMatr1({\n{-1i/sqrt(2), 1i/sqrt(2)},\n{(1i-1)/2,    (1i-1)/2}\n});\n\napplyCompMatr1(qureg, 2, matrix);\n ```\n\n @param[in,out] qureg  the state to modify.\n @param[in]     target the index of the target qubit.\n @param[in]     matrix the Z-basis unitary matrix to effect.\n @throws invalidQuESTInputError()\n - if @p qureg or @p matrix are uninitialised.\n - if @p matrix is not approximately unitary.\n - if @p target is an invalid qubit index.\n @see\n - getCompMatr1()\n - getInlineCompMatr1()\n - multiplyCompMatr1()\n - applyControlledCompMatr1()\n - applyCompMatr2()\n - applyCompMatr()\n @author Tyson Jones"]
    pub fn applyCompMatr1(qureg: Qureg, target: ::std::os::raw::c_int, matrix: CompMatr1);
}
extern "C" {
    #[doc = " Applies a singly-controlled one-qubit dense unitary @p matrix to the specified\n @p target qubit of @p qureg.\n\n @diagram\n @dot\ndigraph {\nrankdir=LR;\nnode [fontsize=10, fontname=\"Menlo\"];\nedge [dir=none];\n\ntopWireL [shape=plaintext, label=\"control\"];\ntopWireR [shape=plaintext, label=\"\"];\nctrl  [shape=circle, label=\"\", width=.12, style=filled, fillcolor=black];\n\ntopWireL -> ctrl -> topWireR;\n\nbotWireL [shape=plaintext, label=\"target\"];\nbotWireR [shape=plaintext, label=\"\"];\ngate  [shape=box,    label=\"matrix\"];\n\nbotWireL -> gate -> botWireR;\nctrl -> gate;\n\n{rank=same; topWireL; botWireL};\n{rank=same; ctrl;     gate};\n{rank=same; topWireR; botWireR};\n}\n @enddot\n\n @notdoced"]
    pub fn applyControlledCompMatr1(
        qureg: Qureg,
        control: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
        matrix: CompMatr1,
    );
}
extern "C" {
    #[doc = " Applies a multiply-controlled one-qubit dense unitary @p matrix to the specified\n @p target qubit of @p qureg.\n\n @diagram\n @dot\ndigraph {\nrankdir=LR;\nnode [fontsize=10, fontname=\"Menlo\"];\nedge [dir=none];\n\ntrailingCtrl [shape=plaintext, label=\"...\"];\n\ntopWireL [shape=plaintext, label=\"controls[1]\"];\ntopWireR [shape=plaintext, label=\"\"];\ntopCtrl  [shape=circle, label=\"\", width=.12, style=filled, fillcolor=black];\n\ntopWireL -> topCtrl -> topWireR;\n\nmidWireL [shape=plaintext, label=\"controls[0]\"];\nmidWireR [shape=plaintext, label=\"\"];\nmidCtrl  [shape=circle, label=\"\", width=.12, style=filled, fillcolor=black];\n\nmidWireL -> midCtrl -> midWireR;\n\nbotWireL [shape=plaintext, label=\"target\"];\nbotWireR [shape=plaintext, label=\"\"];\ngate  [shape=box,    label=\"matrix\"];\n\nbotWireL -> gate -> botWireR;\ntrailingCtrl -> topCtrl -> midCtrl -> gate;\n\n{rank=same; topWireL; midWireL; botWireL};\n{rank=same; trailingCtrl; topCtrl; midCtrl; gate};\n{rank=same; topWireR; midWireR; botWireR};\n}\n @enddot\n\n @notdoced"]
    pub fn applyMultiControlledCompMatr1(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
        matrix: CompMatr1,
    );
}
extern "C" {
    #[doc = " Applies an arbitrarily-controlled one-qubit dense unitary @p matrix to the specified\n @p target qubit of @p qureg, conditioned upon the @p controls being in the given @p states.\n\n @diagram\n @dot\ndigraph {\nrankdir=LR;\nnode [fontsize=10, fontname=\"Menlo\"];\nedge [dir=none];\n\ntrailingCtrl [shape=plaintext, label=\"...\"];\n\ntopWireL [shape=plaintext, label=\"controls[1]\"];\ntopWireR [shape=plaintext, label=\"\"];\ntopCtrl  [shape=circle, label=\"\", width=.12, style=filled, fillcolor=black];\n\ntopWireL -> topCtrl -> topWireR;\n\nmidWireL [shape=plaintext, label=\"controls[0]\"];\nmidWireR [shape=plaintext, label=\"\"];\nmidCtrl  [shape=circle, label=\"\", width=.12, style=filled, fillcolor=white];\n\nmidWireL -> midCtrl -> midWireR;\n\nbotWireL [shape=plaintext, label=\"target\"];\nbotWireR [shape=plaintext, label=\"\"];\ngate  [shape=box,    label=\"matrix\"];\n\nbotWireL -> gate -> botWireR;\ntrailingCtrl -> topCtrl -> midCtrl -> gate;\n\n{rank=same; topWireL; midWireL; botWireL};\n{rank=same; trailingCtrl; topCtrl; midCtrl; gate};\n{rank=same; topWireR; midWireR; botWireR};\n}\n @enddot\n\n @notdoced"]
    pub fn applyMultiStateControlledCompMatr1(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        states: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
        matrix: CompMatr1,
    );
}
extern "C" {
    #[doc = " Applies a general two-qubit dense unitary @p matrix to qubits @p target1 and\n @p target2 (treated as increasing significance) of @p qureg.\n\n @diagram\n @dot\ndigraph {\nlayout=neato;\nrankdir=LR;\nnode [fontsize=10, fontname=\"Menlo\"];\nedge [dir=none];\n\ntopWireL [shape=plaintext, pos=\"0,0!\", label=\"target2\"];\ntopWireR [shape=plaintext, pos=\"2.5,0!\", label=\"\"];\n\nbotWireL [shape=plaintext, pos=\"0,.5!\", label=\"target1\"];\nbotWireR [shape=plaintext, pos=\"2.5,.5!\", label=\"\"];\n\ngate  [shape=rectangle, label=\"matrix\", style=filled, fillcolor=white, height=1, pos=\"1.25,.25!\"];\n\ntopWireL -> topWireR;\nbotWireL -> botWireR;\n}\n @enddot\n\n @notdoced"]
    pub fn applyCompMatr2(
        qureg: Qureg,
        target1: ::std::os::raw::c_int,
        target2: ::std::os::raw::c_int,
        matrix: CompMatr2,
    );
}
extern "C" {
    #[doc = " Applies a singly-controlled two-qubit dense unitary @p matrix to qubits\n @p target1 and @p target2 (treated as increasing significance) of @p qureg.\n\n @diagram\n @dot\ndigraph {\nlayout=neato;\nrankdir=LR;\nnode [fontsize=10, fontname=\"Menlo\"];\nedge [dir=none];\n\ntopWireL [shape=plaintext, pos=\"0,1!\", label=\"control\"];\ntopWireR [shape=plaintext, pos=\"2.5,1!\", label=\"\"];\n\nmidWireL [shape=plaintext, pos=\"0,0.5!\", label=\"target2\"];\nmidWireR [shape=plaintext, pos=\"2.5,0.5!\", label=\"\"];\n\nbotWireL [shape=plaintext, pos=\"0,0!\", label=\"target1\"];\nbotWireR [shape=plaintext, pos=\"2.5,0!\", label=\"\"];\n\ngate [shape=rectangle, label=\"matrix\", style=filled, fillcolor=white, height=1, pos=\"1.25,0.25!\"];\nctrl [shape=circle, label=\"\", width=.12, style=filled, fillcolor=black, pos=\"1.25,1!\"];\n\ntopWireL -> ctrl -> topWireR;\nmidWireL -> midWireR;\nbotWireL -> botWireR;\nctrl -> gate;\n}\n @enddot\n\n @notdoced"]
    pub fn applyControlledCompMatr2(
        qureg: Qureg,
        control: ::std::os::raw::c_int,
        target1: ::std::os::raw::c_int,
        target2: ::std::os::raw::c_int,
        matr: CompMatr2,
    );
}
extern "C" {
    #[doc = " Applies a multiply-controlled two-qubit dense unitary @p matrix to qubits\n @p target1 and @p target2 (treated as increasing significance) of @p qureg.\n\n @diagram\n @dot\ndigraph {\nlayout=neato;\nrankdir=LR;\nnode [fontsize=10, fontname=\"Menlo\"];\nedge [dir=none];\n\ntippytopWireL [shape=plaintext, pos=\"0,1.5!\", label=\"controls[1]\"];\ntippytopWireR [shape=plaintext, pos=\"2.5,1.5!\", label=\"\"];\n\ntopWireL [shape=plaintext, pos=\"0,1!\", label=\"controls[0]\"];\ntopWireR [shape=plaintext, pos=\"2.5,1!\", label=\"\"];\n\nmidWireL [shape=plaintext, pos=\"0,0.5!\", label=\"target2\"];\nmidWireR [shape=plaintext, pos=\"2.5,0.5!\", label=\"\"];\n\nbotWireL [shape=plaintext, pos=\"0,0!\", label=\"target1\"];\nbotWireR [shape=plaintext, pos=\"2.5,0!\", label=\"\"];\n\ngate [shape=rectangle, label=\"matrix\", style=filled, fillcolor=white, height=1, pos=\"1.25,0.25!\"];\nctrl1 [shape=circle, label=\"\", width=.12, style=filled, fillcolor=black, pos=\"1.25,1!\"];\nctrl2 [shape=circle, label=\"\", width=.12, style=filled, fillcolor=black, pos=\"1.25,1.5!\"];\ntrailingCtrl [shape=plaintext, label=\"...\", pos=\"1.25,2!\"];\n\ntippytopWireL -> ctrl2 -> tippytopWireR;\ntopWireL -> ctrl1 -> topWireR;\nmidWireL -> midWireR;\nbotWireL -> botWireR;\ntrailingCtrl -> ctrl2 -> ctrl1 -> gate;\n}\n @enddot\n\n @notdoced"]
    pub fn applyMultiControlledCompMatr2(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target1: ::std::os::raw::c_int,
        target2: ::std::os::raw::c_int,
        matr: CompMatr2,
    );
}
extern "C" {
    #[doc = " Applies an arbitrarily-controlled two-qubit dense unitary @p matrix to qubits\n @p target1 and @p target2 (treated as increasing significance) of @p qureg,\n conditioned upon the @p controls being in the given @p states.\n\n @diagram\n @dot\ndigraph {\nlayout=neato;\nrankdir=LR;\nnode [fontsize=10, fontname=\"Menlo\"];\nedge [dir=none];\n\ntippytopWireL [shape=plaintext, pos=\"0,1.5!\", label=\"controls[1]\"];\ntippytopWireR [shape=plaintext, pos=\"2.5,1.5!\", label=\"\"];\n\ntopWireL [shape=plaintext, pos=\"0,1!\", label=\"controls[0]\"];\ntopWireR [shape=plaintext, pos=\"2.5,1!\", label=\"\"];\n\nmidWireL [shape=plaintext, pos=\"0,0.5!\", label=\"target2\"];\nmidWireR [shape=plaintext, pos=\"2.5,0.5!\", label=\"\"];\n\nbotWireL [shape=plaintext, pos=\"0,0!\", label=\"target1\"];\nbotWireR [shape=plaintext, pos=\"2.5,0!\", label=\"\"];\n\ngate [shape=rectangle, label=\"matrix\", style=filled, fillcolor=white, height=1, pos=\"1.25,0.25!\"];\nctrl1 [shape=circle, label=\"\", width=.12, style=filled, fillcolor=white, pos=\"1.25,1!\"];\nctrl2 [shape=circle, label=\"\", width=.12, style=filled, fillcolor=black, pos=\"1.25,1.5!\"];\ntrailingCtrl [shape=plaintext, label=\"...\", pos=\"1.25,2!\"];\n\ntippytopWireL -> ctrl2 -> tippytopWireR;\ntopWireL -> ctrl1 -> topWireR;\nmidWireL -> midWireR;\nbotWireL -> botWireR;\ntrailingCtrl -> ctrl2 -> ctrl1 -> gate;\n}\n @enddot\n\n @notdoced"]
    pub fn applyMultiStateControlledCompMatr2(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        states: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target1: ::std::os::raw::c_int,
        target2: ::std::os::raw::c_int,
        matr: CompMatr2,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyCompMatr(
        qureg: Qureg,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
        matr: CompMatr,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyControlledCompMatr(
        qureg: Qureg,
        control: ::std::os::raw::c_int,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
        matr: CompMatr,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiControlledCompMatr(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
        matr: CompMatr,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiStateControlledCompMatr(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        states: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
        matr: CompMatr,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyDiagMatr1(qureg: Qureg, target: ::std::os::raw::c_int, matr: DiagMatr1);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyControlledDiagMatr1(
        qureg: Qureg,
        control: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
        matr: DiagMatr1,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiControlledDiagMatr1(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
        matr: DiagMatr1,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiStateControlledDiagMatr1(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        states: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
        matr: DiagMatr1,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyDiagMatr2(
        qureg: Qureg,
        target1: ::std::os::raw::c_int,
        target2: ::std::os::raw::c_int,
        matr: DiagMatr2,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyControlledDiagMatr2(
        qureg: Qureg,
        control: ::std::os::raw::c_int,
        target1: ::std::os::raw::c_int,
        target2: ::std::os::raw::c_int,
        matr: DiagMatr2,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiControlledDiagMatr2(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target1: ::std::os::raw::c_int,
        target2: ::std::os::raw::c_int,
        matr: DiagMatr2,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiStateControlledDiagMatr2(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        states: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target1: ::std::os::raw::c_int,
        target2: ::std::os::raw::c_int,
        matr: DiagMatr2,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyDiagMatr(
        qureg: Qureg,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
        matrix: DiagMatr,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyControlledDiagMatr(
        qureg: Qureg,
        control: ::std::os::raw::c_int,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
        matrix: DiagMatr,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiControlledDiagMatr(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
        matrix: DiagMatr,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiStateControlledDiagMatr(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        states: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
        matrix: DiagMatr,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyDiagMatrPower(
        qureg: Qureg,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
        matrix: DiagMatr,
        exponent: qcomp,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyControlledDiagMatrPower(
        qureg: Qureg,
        control: ::std::os::raw::c_int,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
        matrix: DiagMatr,
        exponent: qcomp,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiControlledDiagMatrPower(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
        matrix: DiagMatr,
        exponent: qcomp,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiStateControlledDiagMatrPower(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        states: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
        matrix: DiagMatr,
        exponent: qcomp,
    );
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn applyFullStateDiagMatr(qureg: Qureg, matrix: FullStateDiagMatr);
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn applyFullStateDiagMatrPower(qureg: Qureg, matrix: FullStateDiagMatr, exponent: qcomp);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyS(qureg: Qureg, target: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyControlledS(
        qureg: Qureg,
        control: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiControlledS(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiStateControlledS(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        states: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyT(qureg: Qureg, target: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyControlledT(
        qureg: Qureg,
        control: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiControlledT(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiStateControlledT(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        states: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyHadamard(qureg: Qureg, target: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyControlledHadamard(
        qureg: Qureg,
        control: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiControlledHadamard(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiStateControlledHadamard(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        states: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Applies a SWAP gate between @p qubit1 and @p qubit2 of @p qureg.\n\n @diagram\n @dot\ndigraph {\nrankdir=LR;\nlayout=neato;\nnode [fontsize=10, fontname=\"Menlo\"];\nedge [dir=none];\n\ntopWireL [shape=plaintext, label=\"qubit2\", pos=\"0,.5!\"];\ntopWireM [shape=point, label=\"\", width=0, pos=\".75,.5!\"];\ntopWireR [shape=plaintext, label=\"\", pos=\"1.5,.5!\"];\n\nbotWireL [shape=plaintext, label=\"qubit1\", pos=\"0,0!\"];\nbotWireM [shape=point, label=\"\", width=0, pos=\".75,0!\"];\nbotWireR [shape=plaintext, label=\"\", pos=\"1.5,0!\"];\n\ntopWireL -> topWireR;\nbotWireL -> botWireR;\nbotWireM -> topWireM;\n\ntopX [shape=plaintext, label=\"✕\", pos=\".75,.5!\", fontsize=15];\nbotX [shape=plaintext, label=\"✕\", pos=\".75,0!\",  fontsize=15];\n}\n @enddot\n\n @notdoced"]
    pub fn applySwap(qureg: Qureg, qubit1: ::std::os::raw::c_int, qubit2: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyControlledSwap(
        qureg: Qureg,
        control: ::std::os::raw::c_int,
        qubit1: ::std::os::raw::c_int,
        qubit2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiControlledSwap(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        qubit1: ::std::os::raw::c_int,
        qubit2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiStateControlledSwap(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        states: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        qubit1: ::std::os::raw::c_int,
        qubit2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applySqrtSwap(
        qureg: Qureg,
        qubit1: ::std::os::raw::c_int,
        qubit2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyControlledSqrtSwap(
        qureg: Qureg,
        control: ::std::os::raw::c_int,
        qubit1: ::std::os::raw::c_int,
        qubit2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiControlledSqrtSwap(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        qubit1: ::std::os::raw::c_int,
        qubit2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiStateControlledSqrtSwap(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        states: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        qubit1: ::std::os::raw::c_int,
        qubit2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyPauliX(qureg: Qureg, target: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyPauliY(qureg: Qureg, target: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyPauliZ(qureg: Qureg, target: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyControlledPauliX(
        qureg: Qureg,
        control: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyControlledPauliY(
        qureg: Qureg,
        control: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyControlledPauliZ(
        qureg: Qureg,
        control: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiControlledPauliX(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiControlledPauliY(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiControlledPauliZ(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiStateControlledPauliX(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        states: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiStateControlledPauliY(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        states: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiStateControlledPauliZ(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        states: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyPauliStr(qureg: Qureg, str_: PauliStr);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyControlledPauliStr(qureg: Qureg, control: ::std::os::raw::c_int, str_: PauliStr);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiControlledPauliStr(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        str_: PauliStr,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiStateControlledPauliStr(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        states: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        str_: PauliStr,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyRotateX(qureg: Qureg, target: ::std::os::raw::c_int, angle: qreal);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyRotateY(qureg: Qureg, target: ::std::os::raw::c_int, angle: qreal);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyRotateZ(qureg: Qureg, target: ::std::os::raw::c_int, angle: qreal);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyControlledRotateX(
        qureg: Qureg,
        control: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
        angle: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyControlledRotateY(
        qureg: Qureg,
        control: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
        angle: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyControlledRotateZ(
        qureg: Qureg,
        control: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
        angle: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiControlledRotateX(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
        angle: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiControlledRotateY(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
        angle: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiControlledRotateZ(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
        angle: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiStateControlledRotateX(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        states: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
        angle: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiStateControlledRotateY(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        states: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
        angle: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiStateControlledRotateZ(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        states: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        target: ::std::os::raw::c_int,
        angle: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyRotateAroundAxis(
        qureg: Qureg,
        targ: ::std::os::raw::c_int,
        angle: qreal,
        axisX: qreal,
        axisY: qreal,
        axisZ: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyControlledRotateAroundAxis(
        qureg: Qureg,
        ctrl: ::std::os::raw::c_int,
        targ: ::std::os::raw::c_int,
        angle: qreal,
        axisX: qreal,
        axisY: qreal,
        axisZ: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiControlledRotateAroundAxis(
        qureg: Qureg,
        ctrls: *mut ::std::os::raw::c_int,
        numCtrls: ::std::os::raw::c_int,
        targ: ::std::os::raw::c_int,
        angle: qreal,
        axisX: qreal,
        axisY: qreal,
        axisZ: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiStateControlledRotateAroundAxis(
        qureg: Qureg,
        ctrls: *mut ::std::os::raw::c_int,
        states: *mut ::std::os::raw::c_int,
        numCtrls: ::std::os::raw::c_int,
        targ: ::std::os::raw::c_int,
        angle: qreal,
        axisX: qreal,
        axisY: qreal,
        axisZ: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyPauliGadget(qureg: Qureg, str_: PauliStr, angle: qreal);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyControlledPauliGadget(
        qureg: Qureg,
        control: ::std::os::raw::c_int,
        str_: PauliStr,
        angle: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiControlledPauliGadget(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        str_: PauliStr,
        angle: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiStateControlledPauliGadget(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        states: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        str_: PauliStr,
        angle: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyPhaseGadget(
        qureg: Qureg,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
        angle: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyControlledPhaseGadget(
        qureg: Qureg,
        control: ::std::os::raw::c_int,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
        angle: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiControlledPhaseGadget(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
        angle: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiStateControlledPhaseGadget(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        states: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
        angle: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyPhaseFlip(qureg: Qureg, target: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyPhaseShift(qureg: Qureg, target: ::std::os::raw::c_int, angle: qreal);
}
extern "C" {
    #[doc = " Applies a two-qubit phase flip upon @p qubit1 and @p qubit2 of @p qureg.\n\n @diagram\n @dot\ndigraph {\nrankdir=LR;\nlayout=neato;\nnode [fontsize=10, fontname=\"Menlo\"];\nedge [dir=none];\n\ntopWireL [shape=plaintext, label=\"target1\", pos=\"0,.5!\"];\ntopWireM [shape=point, label=\"\", width=.1, pos=\".75,.5!\"]\ntopWireR [shape=plaintext, label=\"\", pos=\"1.5,.5!\"];\n\nbotWireL [shape=plaintext, label=\"target2\", pos=\"0,0!\"];\nbotWireM [shape=point, label=\"\", width=.1, pos=\".75,0!\"];\nbotWireR [shape=plaintext, label=\"\", pos=\"1.5,0!\"];\n\ntopWireL -> topWireR;\nbotWireL -> botWireR;\nbotWireM -> topWireM;\n}\n @enddot\n\n @notdoced"]
    pub fn applyTwoQubitPhaseFlip(
        qureg: Qureg,
        target1: ::std::os::raw::c_int,
        target2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Applies a two-qubit phase flip upon @p qubit1 and @p qubit2 of @p qureg.\n\n @diagram\n @dot\ndigraph {\nrankdir=LR;\nlayout=neato;\nnode [fontsize=10, fontname=\"Menlo\"];\nedge [dir=none];\n\ntopWireL [shape=plaintext, label=\"target1\", pos=\"0,.5!\"];\ntopWireM [shape=point, label=\"\", width=.1, pos=\".75,.5!\"]\ntopWireR [shape=plaintext, label=\"\", pos=\"1.5,.5!\"];\n\nbotWireL [shape=plaintext, label=\"target2\", pos=\"0,0!\"];\nbotWireM [shape=point, label=\"\", width=.1, pos=\".75,0!\"];\nbotWireR [shape=plaintext, label=\"\", pos=\"1.5,0!\"];\n\ntopWireL -> topWireR;\nbotWireL -> botWireR;\nbotWireM -> topWireM;\n\nangle [shape=plaintext, label=\"θ\", pos=\".85,-.2!\"];\n}\n @enddot\n\n @notdoced"]
    pub fn applyTwoQubitPhaseShift(
        qureg: Qureg,
        target1: ::std::os::raw::c_int,
        target2: ::std::os::raw::c_int,
        angle: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiQubitPhaseFlip(
        qureg: Qureg,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiQubitPhaseShift(
        qureg: Qureg,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
        angle: qreal,
    );
}
extern "C" {
    #[doc = " @notdoced\n @nottested"]
    pub fn applyTrotterizedPauliStrSumGadget(
        qureg: Qureg,
        sum: PauliStrSum,
        angle: qreal,
        order: ::std::os::raw::c_int,
        reps: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiQubitNot(
        qureg: Qureg,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyControlledMultiQubitNot(
        qureg: Qureg,
        control: ::std::os::raw::c_int,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiControlledMultiQubitNot(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced"]
    pub fn applyMultiStateControlledMultiQubitNot(
        qureg: Qureg,
        controls: *mut ::std::os::raw::c_int,
        states: *mut ::std::os::raw::c_int,
        numControls: ::std::os::raw::c_int,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn applyQubitMeasurement(
        qureg: Qureg,
        target: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn applyQubitMeasurementAndGetProb(
        qureg: Qureg,
        target: ::std::os::raw::c_int,
        probability: *mut qreal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn applyForcedQubitMeasurement(
        qureg: Qureg,
        target: ::std::os::raw::c_int,
        outcome: ::std::os::raw::c_int,
    ) -> qreal;
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn applyMultiQubitMeasurement(
        qureg: Qureg,
        qubits: *mut ::std::os::raw::c_int,
        numQubits: ::std::os::raw::c_int,
    ) -> qindex;
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn applyMultiQubitMeasurementAndGetProb(
        qureg: Qureg,
        qubits: *mut ::std::os::raw::c_int,
        numQubits: ::std::os::raw::c_int,
        probability: *mut qreal,
    ) -> qindex;
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn applyForcedMultiQubitMeasurement(
        qureg: Qureg,
        qubits: *mut ::std::os::raw::c_int,
        outcomes: *mut ::std::os::raw::c_int,
        numQubits: ::std::os::raw::c_int,
    ) -> qreal;
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn applyQubitProjector(
        qureg: Qureg,
        target: ::std::os::raw::c_int,
        outcome: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn applyMultiQubitProjector(
        qureg: Qureg,
        qubits: *mut ::std::os::raw::c_int,
        outcomes: *mut ::std::os::raw::c_int,
        numQubits: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn applyQuantumFourierTransform(
        qureg: Qureg,
        targets: *mut ::std::os::raw::c_int,
        numTargets: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @notdoced\n @notvalidated"]
    pub fn applyFullQuantumFourierTransform(qureg: Qureg);
}
